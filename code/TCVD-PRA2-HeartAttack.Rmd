---
title: 'UOC - Tipologia y ciclo de vida de los datos - PRA2'
subtitle: 'Limpieza y Preprocesado: Heart Attack Analysis & Prediction Dataset'
author: 'Vanessa Moreno González, Manuel Ernesto Martínez Martín'
date: '`r format(Sys.Date(),"%e de %B %Y")`'
lang: es-ES
fontsize: 10pt
output:
  pdf_document:
    highlight: default
    toc: yes
    toc_depth: 2
  word_document: default
  html_document:
    highlight: default
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
# Librerias
if(!require("corrplot")) install.packages("corrplot"); library("corrplot")
# PCA
if(!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('factoextra')) install.packages('factoextra'); library('factoextra')
if (!require('gridExtra')) install.packages('gridExtra'); library('gridExtra')
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack <- read.csv('../data/heart_in.csv')
```

\newpage

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack.var_names <- sub(",\\s(?!.*,\\s)", " y ", paste(names(heartAttack), collapse = ", "), perl = TRUE)
```

# 1. Descripción del dataset

Este dataset trae dos ficheros `heart.csv` y `o2Saturation.csv` y **es importante porque proporciona información sobre factores relacionados con enfermedades cardíacas**, como edad, sexo, síntomas otros datos médicos. Ya que con el **se puede entender mejor la enfermedad y hacer un análisis para detectar cuando se puede estar en riesgo de ataque cardíaco**, sabiendo esto se pueden desarrollar modelos predictivos que tomen decisiones para ayudar a prevenir un ataque cardíaco.

El dataset es el propuesto en el enunciado de la práctica y se ha extraído de kaggel: [**Heart Attack Analysis & Prediction Dataset**](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset)

## Contenido del dataset {.unlisted .unnumbered}

Las variables que tiene el dataset son: `r toString(heartAttack.var_names)`. Siendo `output` la variable objetivo. A continuación se detallan más en profundidad.

+ **age**: Edad del paciente.
+ **sex**: Género del paciente.
  - *0*: Femenino
  - *1*: Masculino
+ **cp**: Tipo de dolor en el pecho.
  - *0*: Angina típica
  - *1*: Angina atípica
  - *2*: Dolor no anginal
  - *3*: Asintomático
+ **trtbps**: Presión arterial en reposo (en mm Hg).
+ **chol**: Colesterol en mg/dl medido mediante un sensor BMI.
+ **fbs**: Nivel de azúcar en sangre en ayunas (> 120 mg/dl).
  - *1*: Verdadero
  - *0*: Falso
+ **restecg**: Resultados electrocardiográficos en reposo.
  - *0*: Normal
  - *1*: Anormalidad con inversiones de onda ST-T y/o alteraciones del segmento ST > 0.05 mV
  - *2*: Hipertrofia ventricular izquierda
+ **thalachh**: Ritmo cardíaco máximo alcanzado.
+ **exng**: Angina inducida por ejercicio.
  - *1*: Sí
  - *0*: No
+ **oldpeak**: Diferencia entre la depresión del segmento ST durante el ejercicio y durante el descanso en un electrocardiograma.
+ **slp**: Pendiente del segmento ST durante el ejercicio en la prueba de esfuerzo.
  - *1*: Ascendente
  - *2*: Plana
  - *3*: Descendente
+ **caa**: Número de vasos principales (0-3).
+ **thall**:  Talasemia, trastorno hereditario de la sangre caracterizado por un menor nivel de hemoglobina.
  - *0*: Ausencia
  - *1*: Talasemia normal
  - *2*: Talasemia fija defectuosa
  - *3*: Talasemia Reversible defectuosa
+ **output**: Variable objetivo.
  - *0*: Menor probabilidad de ataque al corazón
  - *1*: Mayor probabilidad de ataque al corazón

***

# 2. Integración y selección de variables

Observando los dos ficheros csv, **`heart.csv`** tiene **`r ncol(heartAttack)` variables** y **`r nrow(heartAttack)` registros** mientras que **`o2Saturation.csv`** con **1 variable** y **3585 registros**.

Aunque el nivel de saturación de oxigeno pueda ser importante para los ataques cardíacos, no hay manera de juntar los dos conjuntos de datos en uno solo debido a que no hay un identificador de paciente, por lo que solo usaremos `heart.csv`.

Para la selección de los datos, aprovechando de que todas las variables son numéricas se puede comprobar la correlación entre ellas

```{r echo=FALSE, message=FALSE, warning=FALSE}
cor.pearson <- cor(heartAttack, method= "pearson")
corrplot(cor.pearson,method="color",tl.col="black", tl.srt=45, order = "AOE", tl.cex=0.7,
number.cex=0.7,sig.level = 0.01, addCoef.col = "firebrick")

cor.pearson.output <- round(cor.pearson["output",],2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
cor.pearson.length <- length(names(cor.pearson.output))
cor.pearson.output.row <-
  paste(paste0(names(cor.pearson.output)[-cor.pearson.length], " = ", cor.pearson.output[-cor.pearson.length]), collapse = ", ")
cor.pearson.output.rowFixed <- sub(",\\s(?!.*,\\s)", " y ", cor.pearson.output.row, perl = TRUE)
```

Tanto una correlación positiva como una muy negativa son interesantes para la selección de variables. Centrándonos en la fila de la variable objetivo `output` se tienen los siguientes valores: `r cor.pearson.output.rowFixed`.

Se puede tomar como referencia 0.15 como umbral para comprobar las variables que no son necesarias para el estudio, siempre en valor absoluto. En este caso para el coeficiente de correlación de pearson se tienen `exng`, `oldpeak`, `cp`, `thalachh`, `caa`, `slp`, `thall`, `sex` y `age` como variables aptas y `trtbps`, `restecg`, `chol` y `fbs` como poco importantes. Sin embargo para las variables categóricas numéricas seria más apropiado hacer un test de `Fisher` o un `Chi-squared`.

Se va a proceder a hacer uso del test de `Fisher` con `fisher.test()`

$p = \frac{{\binom{{a+b}}{{a}} \cdot \binom{{c+d}}{{c}}}}{{\binom{{n}}{{a+c}}}}$

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack.fisher.sex <- fisher.test(heartAttack$sex, heartAttack$output)
heartAttack.fisher.sex

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.cp <- fisher.test(heartAttack$cp, heartAttack$output)
heartAttack.fisher.cp

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.fbs <- fisher.test(heartAttack$fbs, heartAttack$output)
heartAttack.fisher.fbs

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.restecg <- fisher.test(heartAttack$restecg, heartAttack$output)
heartAttack.fisher.restecg

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.exng <- fisher.test(heartAttack$exng, heartAttack$output)
heartAttack.fisher.exng

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.slp <- fisher.test(heartAttack$slp, heartAttack$output)
heartAttack.fisher.slp

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.caa <- fisher.test(heartAttack$caa, heartAttack$output)
heartAttack.fisher.caa

cat(paste(rep("#", 50), collapse = ""))

heartAttack.fisher.thall <- fisher.test(heartAttack$thall, heartAttack$output)
heartAttack.fisher.thall
```

Se entiende entonces que las variables que tienen un *p-valor* por debajo de un nivel de significancia de `0.05` son consideradas buenas para ser escogidas para el análisis, es decir estas variables tienen un buen nivel estadístico de significancia y aportan información a los posibles modelos en las que se incluyan. De las variabels categoricas seleccionadas todas menos `fbs` tienen un p-valor por debajo de `0.05`.

Puesto que `fbs` no es una variable significativa se va a evitar su uso.

***

# 3. Limpieza de los datos

En primer lugar se va a comprobar la estructura con `str()`

```{r echo=FALSE, message=FALSE, warning=FALSE}
str(heartAttack)
```

Como se puede observar todos los datos son números, los hay de tipo integer y de tipo numeric, para un mejor análisis, los datos de tipo integer deberían ser de tipo numeric (si hubiera cadenas estas deberían ser de tipo factor ya que ocupan menos memoria y se utilizan así en muchos modelos predictivos). Para ello se va a utilizar `mutate_if()` con `is.integer`

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack <- heartAttack %>% mutate_if(is.integer, as.numeric)
```

Y ahora se va a ver un resumen general de cada una de las variables con sus valores máximos, mínimos media, mean y cuartiles utilizando la función `summary()`. Es aquí donde en los casos numéricos se pueden ver si hay valores imposibles de cumplir tanto en máximos como en mínimos.

```{r echo=FALSE, message=FALSE, warning=FALSE}
summary(heartAttack)
```

De la variable `caa` se tenían identificados valores de 0 a 3, pero el valor máximos es 4.

## 3.1. ¿Los datos contienen ceros o elementos vacíos?

Cuando en un dataset se tienen datos nulos, hay una serie de estrategias a seguir para solucionar esto y que el juego de datos se pueda usar:

+ **Eliminación de los registros**, esto a veces no es adecuado porque puede perderse mucha información que hay en otras variables que pueden ser más importantes.
+ **Imputación de un valor** que puede ser: utilizar la media, la mediana, la moda, interpolación, utilización de los vecinos cercanos, u otros métodos.

### Búsqueda de ceros

Tenemos algunas variables categóricas en formato numérico en nuestro conjunto de datos. Estas variables no se pueden considerar en la búsqueda de ceros, ya que el valor `0` es una de las posibles categorías para cada una de ellas. Las variables categóricas en formato numérico son `sex`, `cp`, `fbs`, `restecg`, `exng`, `slp`,`caa`, `thall` y la target `output`. De las cuales son dicotomicas `sex`, `fbs`, `exng` y `output`.

También en el resumen mostrado anterior se podía ver a simple vista si alguna variable tenía 0 si este fuera su valor mínimo.

Para buscar los valores nulos podemos usar `colSums()` y comprobando con un `=` como a continuación

```{r echo=TRUE, message=FALSE, warning=FALSE}
selectedColumns <- c("age", "trtbps", "chol", "thalachh", "oldpeak")
colSums(heartAttack %>% select(all_of(selectedColumns)) == 0)
```

+ **age**: Hay `r length(which(heartAttack$age==0))` pacientes con 0 años.
+ **trtbps**: Hay `r length(which(heartAttack$trtbps==0))` pacientes con 0 o sin presión arterial en reposo.
+ **chol**: Hay `r length(which(heartAttack$chol==0))` pacientes con 0 o sin medición de colesterol.
+ **thalachh**: Hay `r length(which(heartAttack$thalach==0))` pacientes con 0 o sin ritmo cardíaco máximo alcanzado.
+ **oldpeak**: Hay `r length(which(heartAttack$oldpeak==0))` pacientes con 0 o sin informar de la diferencia en segmento ST con electrocardiograma.

### Búsqueda de NAs

Para buscar los valores nulos podemos usar de nuevo `colSums()` pero ahora con `is.na()`

```{r echo=TRUE, message=FALSE, warning=FALSE}
colSums(is.na(heartAttack))
```

Como se puede observar **no hay valores `NA`** en este dataset, otra comprobación sería buscar valores en blanco, pero esto se haría si hubiera variables categoricas que fueran cadenas, en este caso no es necesario ya que no hay ningún valor como texto.

## 3.2. Identifica y gestiona los valores extremos

FIXME

***

# 4. Análisis de los datos

FIXME

## 4.1. Selección de los grupos de datos que se quieren analizar/comparar

FIXME

## 4.2. Comprobación de la normalidad y homogeneidad de la varianza

FIXME

## 4.3. Aplicación de pruebas estadísticas para comparar los grupos de datos

FIXME

***

# 5. Representación de los resultados

FIXME

***

# 6. Resolución del problema

FIXME

***

# 7. Código

FIXME

***

# 8. Vídeo

FIXME