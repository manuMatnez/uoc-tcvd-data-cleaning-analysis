---
title: 'UOC - Tipologia y ciclo de vida de los datos - PRA2'
subtitle: 'Limpieza y Preprocesado: Heart Attack Analysis & Prediction Dataset'
author: 'Vanessa Moreno González, Manuel Ernesto Martínez Martín'
date: '`r format(Sys.Date(),"%e de %B %Y")`'
lang: es-ES
fontsize: 10pt
output:
  html_document:
    highlight: default
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: default
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
# Librerias
if(!require("corrplot")) install.packages("corrplot"); library("corrplot")
# PCA
if(!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('factoextra')) install.packages('factoextra'); library('factoextra')
if (!require('gridExtra')) install.packages('gridExtra'); library('gridExtra')
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack <- read.csv('../data/heart_in.csv')
```

\newpage

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack.var_names <- sub(",\\s(?!.*,\\s)", " y ", paste(names(heartAttack), collapse = ", "), perl = TRUE)
```

# 1. Descripción del dataset

Este dataset trae dos ficheros `heart.csv` y `o2Saturation.csv` y **es importante porque proporciona información sobre factores relacionados con enfermedades cardíacas**, como edad, sexo, síntomas otros datos médicos. Ya que con el **se puede entender mejor la enfermedad y hacer un análisis para detectar cuando se puede estar en riesgo de ataque cardíaco**, sabiendo esto se pueden desarrollar modelos predictivos que tomen decisiones para ayudar a prevenir un ataque cardíaco.

El dataset es el propuesto en el enunciado de la práctica y se ha extraído de kaggel: [**Heart Attack Analysis & Prediction Dataset**](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset)

## Contenido del dataset {.unlisted .unnumbered}

Las variables que tiene el dataset son: `r toString(heartAttack.var_names)`. Siendo `output` la variable objetivo. A continuación se detallan más en profundidad.

+ **age**: Edad del paciente.
+ **sex**: Género del paciente.
  - *0*: Femenino
  - *1*: Masculino
+ **cp**: Tipo de dolor en el pecho.
  - *0*: Angina típica
  - *1*: Angina atípica
  - *2*: Dolor no anginal
  - *3*: Asintomático
+ **trtbps**: Presión arterial en reposo (en mm Hg).
+ **chol**: Colesterol en mg/dl medido mediante un sensor BMI.
+ **fbs**: Nivel de azúcar en sangre en ayunas (> 120 mg/dl).
  - *1*: Verdadero
  - *0*: Falso
+ **restecg**: Resultados electrocardiográficos en reposo.
  - *0*: Normal
  - *1*: Anormalidad con inversiones de onda ST-T y/o alteraciones del segmento ST > 0.05 mV
  - *2*: Hipertrofia ventricular izquierda
+ **thalach**: Ritmo cardíaco máximo alcanzado.
+ **exang**: Angina inducida por ejercicio.
  - *1*: Sí
  - *0*: No
+ **oldpeak**: Diferencia entre la depresión del segmento ST durante el ejercicio y durante el descanso en un electrocardiograma.
+ **slp**: Pendiente del segmento ST durante el ejercicio en la prueba de esfuerzo.
  - *1*: Ascendente
  - *2*: Plana
  - *3*: Descendente
+ **caa**: Número de vasos principales (0-3).
+ **thall**:  Talasemia, trastorno hereditario de la sangre caracterizado por un menor nivel de hemoglobina.
  - *0*: Ausencia
  - *1*: Talasemia normal
  - *2*: Talasemia fija defectuosa
  - *3*: Talasemia Reversible defectuosa
+ **output**: Variable objetivo.
  - *0*: Menor probabilidad de ataque al corazón
  - *1*: Mayor probabilidad de ataque al corazón

***

# 2. Integración y selección de variables

Observando los dos ficheros csv, **`heart.csv`** tiene **`r ncol(heartAttack)` variables** y **`r nrow(heartAttack)` registros** mientras que **`o2Saturation.csv`** con **1 variable** y **3585 registros**.

Aunque el nivel de saturación de oxigeno pueda ser importante para los ataques cardíacos, no hay manera de juntar los dos conjuntos de datos en uno solo debido a que no hay un identificador de paciente, por lo que solo usaremos `heart.csv`.

Para la selección de los datos, aprovechando de que todas las variables son numéricas se puede comprobar la correlación entre ellas

```{r echo=FALSE, message=FALSE, warning=FALSE}
cor.pearson <- cor(heartAttack, method= "pearson")
corrplot(cor.pearson,method="color",tl.col="black", tl.srt=45, order = "AOE", tl.cex=0.7,
number.cex=0.7,sig.level = 0.01, addCoef.col = "firebrick")

cor.pearson.output <- round(cor.pearson["output",],2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
cor.pearson.length <- length(names(cor.pearson.output))
cor.pearson.output.row <-
  paste(paste0(names(cor.pearson.output)[-cor.pearson.length], " = ", cor.pearson.output[-cor.pearson.length]), collapse = ", ")
cor.pearson.output.rowFixed <- sub(",\\s(?!.*,\\s)", " y ", cor.pearson.output.row, perl = TRUE)
```

Tanto una correlación positiva como una muy negativa son interesantes para la selección de variables. Centrándonos en la fila de la variable objetivo `output` se tienen los siguientes valores: `r cor.pearson.output.rowFixed`.

Se puede tomar como referencia 0.15 como umbral para comprobar las variables que no son necesarias para el estudio, siempre en valor absoluto. En este caso se tienen `exng`, `oldpeak`, `cp`, `thalachh`, `caa`, `slp`, `thall`, `sex` y `age` como variables aptas y `trtbps`, `restecg`, `chol` y `fbs` como poco importantes.

## PCA para comprobar importancia de las variables {.unlisted .unnumbered}

La variable objetivo *output* no debe estar en el PCA, ya que no se quiere predecir a sí misma, sino que se quiere encontrar una combinación de las otras variables que explique la variabilidad de la variable dependiente.

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack.pca <- scale(heartAttack %>% select(-output))
```

Tanto el análisis de componentes principales, *Principal Component Analysis* (PCA), como la descomposición de valores singulares, *Singular Value Decomposition* (SVD), son técnicas que permiten trabajar con nuevas características llamadas componentes, que son independientes entre sí. Estas dos técnicas permiten representar el juego de datos en un nuevo sistema de coordenadas llamado componentes principales. Este sistema está mejor adaptado a la distribución del juego de datos, de forma que recoge mejor su variabilidad.

A continuación se va a aplicar el análisis de componentes principales al dataset

```{r echo=FALSE, message=FALSE, warning=FALSE}
pca.acc <- prcomp(heartAttack.pca)
summary(pca.acc)
```
```{r echo=FALSE, message=FALSE, warning=FALSE}
fviz_eig(pca.acc) + ggtitle("Peso de cada atributo sobre el conjunto de los datos")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# Se calcula la varianza de los componentes principales a partir de la desviación estándar
var_acc <- pca.acc$sdev^2
var_acc.kaiser <- var_acc[var_acc > 1]
var_acc.dim <- paste(paste0("DIM ", seq(1, length(var_acc)), " = ", round(var_acc,4)), collapse = ", ")
var_acc.dim_fixed <- sub(",\\s(?!.*,\\s)", " y ", var_acc.dim, perl = TRUE)
```

A continuación se muestran las varianzas de los componentes principales a partir de la desviación estándar: `r var_acc.dim_fixed`.

Se decide utilizar el método de Káiser para decidir cuales de las variables obtenidas serán escogidas. Este criterio mantendrá todas aquellas variables cuya varianza sea superior a 1, es decir nos quedaríamos con `r length(var_acc.kaiser)` dimensiones.

### Calidad de representación

FIXME

```{r echo=FALSE, message=FALSE, warning=TRUE}
# PCA: Extrae la información sobre las variables
var <- get_pca_var(pca.acc)

# PCA: Extrae la información sobre las observaciones
ind <- get_pca_ind(pca.acc)
```

```{r echo=FALSE, message=FALSE, warning=TRUE}
varCos2 = var$cos2[,1:length(var_acc.kaiser)]
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
corrplot(varCos2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
plot1_pca_var <- fviz_pca_var(pca.acc, axes = c(1, 2), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot2_pca_var <- fviz_pca_var(pca.acc, axes = c(1, 3), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot3_pca_var <- fviz_pca_var(pca.acc, axes = c(1, 4), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot4_pca_var <- fviz_pca_var(pca.acc, axes = c(1, 5), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot5_pca_var <- fviz_pca_var(pca.acc, axes = c(2, 3), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot6_pca_var <- fviz_pca_var(pca.acc, axes = c(2, 4), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot7_pca_var <- fviz_pca_var(pca.acc, axes = c(2, 5), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot8_pca_var <- fviz_pca_var(pca.acc, axes = c(3, 4), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot9_pca_var <- fviz_pca_var(pca.acc, axes = c(3, 5), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
plot10_pca_var <- fviz_pca_var(pca.acc, axes = c(4, 5), col.var = "cos2",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9,repel = TRUE)
```
```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot1_pca_var, plot2_pca_var, plot3_pca_var, plot4_pca_var, ncol = 2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot5_pca_var, plot6_pca_var, plot7_pca_var, plot8_pca_var, ncol = 2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot9_pca_var, plot10_pca_var, ncol = 2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
plot1_contrib <- fviz_contrib(pca.acc, choice = "var", axes = 1)
plot2_contrib <- fviz_contrib(pca.acc, choice = "var", axes = 2)
plot3_contrib <- fviz_contrib(pca.acc, choice = "var", axes = 3)
plot4_contrib <- fviz_contrib(pca.acc, choice = "var", axes = 4)
plot5_contrib <- fviz_contrib(pca.acc, choice = "var", axes = 5)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot1_contrib,plot2_contrib,plot3_contrib,plot4_contrib,plot5_contrib,ncol=2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
varContrib = var$contrib[,1:length(var_acc.kaiser)]
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
corrplot(varContrib, is.cor=FALSE)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
plot1_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(1, 2), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot2_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(1, 3), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot3_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(1, 4), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot4_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(1, 5), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot5_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(2, 3), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot6_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(2, 4), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot7_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(2, 5), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot8_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(3, 4), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot9_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(3, 5), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
plot10_pca_var_contrib <- fviz_pca_var(pca.acc, axes = c(4, 5), col.var = "contrib",gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), labelsize = 3, alpha.var = 0.9)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot1_pca_var_contrib, plot2_pca_var_contrib, plot3_pca_var_contrib, plot4_pca_var_contrib, ncol = 2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot5_pca_var_contrib, plot6_pca_var_contrib, plot7_pca_var_contrib, plot8_pca_var_contrib, ncol = 2)
```

FIXME

```{r echo=FALSE, message=FALSE, warning=FALSE}
grid.arrange(plot9_pca_var_contrib, plot10_pca_var_contrib, ncol = 2)
```

FIXME

***

# 3. Limpieza de los datos



```{r echo=TRUE, message=FALSE, warning=FALSE}
str(heartAttack)
```

FIXME

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(heartAttack)
```

FIXME

```{r echo=TRUE, message=FALSE, warning=FALSE}
# FIXME
```

FIXME

## 3.1. ¿Los datos contienen ceros o elementos vacíos?

Tenemos algunas variables categóricas en formato numérico en nuestro conjunto de datos. Estas variables no se pueden considerar en la búsqueda de ceros, ya que el valor 0 es una de las posibles categorías para cada una de ellas. Las variables categóricas en formato numérico son `sex`, `cp`, `fbs`, `restecg`, `exng`, `slp`,`caa`, `thall` y `output`. De las cuales son dicotomicas `sex`, `fbs`, `exng` y `output`.


+ **age**: Hay `r length(which(heartAttack$age==0))` pacientes con edad 0
+ **trtbps**: `r length(which(heartAttack$trtbps==0))`
+ **chol**: `r length(which(heartAttack$chol==0))`
+ **thalach**: `r length(which(heartAttack$thalach==0))`
+ **oldpeak**: `r length(which(heartAttack$oldpeak==0))`


FIXME

## 3.2. Identifica y gestiona los valores extremos

FIXME

***

# 4. Análisis de los datos

FIXME

## 4.1. Selección de los grupos de datos que se quieren analizar/comparar

FIXME

## 4.2. Comprobación de la normalidad y homogeneidad de la varianza

FIXME

## 4.3. Aplicación de pruebas estadísticas para comparar los grupos de datos

FIXME

***

# 5. Representación de los resultados

FIXME

***

# 6. Resolución del problema

FIXME

***

# 7. Código

FIXME

***

# 8. Vídeo

FIXME