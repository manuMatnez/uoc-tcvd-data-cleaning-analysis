---
title: 'UOC - Tipologia y ciclo de vida de los datos - PRA2'
subtitle: 'Limpieza y Preprocesado: Heart Attack Analysis & Prediction Dataset'
author: 'Vanessa Moreno González, Manuel Ernesto Martínez Martín'
date: '`r format(Sys.Date(),"%e de %B %Y")`'
lang: es-ES
fontsize: 10pt
output:
  html_document:
    highlight: default
    theme: cosmo
    toc: yes
    toc_depth: 2
  word_document: default
  pdf_document:
    highlight: default
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
# Librerias
if(!require("corrplot")) install.packages("corrplot"); library("corrplot")
# PCA
if(!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('factoextra')) install.packages('factoextra'); library('factoextra')
if (!require('gridExtra')) install.packages('gridExtra'); library('gridExtra')
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack <- read.csv('../data/heart_in.csv')
```

\newpage

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack.var_names <- sub(",\\s(?!.*,\\s)", " y ", paste(names(heartAttack), collapse = ", "), perl = TRUE)
```

# 1. Descripción del dataset

Este dataset trae dos ficheros `heart.csv` y `o2Saturation.csv` y **es importante porque proporciona información sobre factores relacionados con enfermedades cardíacas**, como edad, sexo, síntomas otros datos médicos. Ya que con el **se puede entender mejor la enfermedad y hacer un análisis para detectar cuando se puede estar en riesgo de ataque cardíaco**, sabiendo esto se pueden desarrollar modelos predictivos que tomen decisiones para ayudar a prevenir un ataque cardíaco.

El dataset es el propuesto en el enunciado de la práctica y se ha extraído de kaggel: [**Heart Attack Analysis & Prediction Dataset**](https://www.kaggle.com/datasets/rashikrahmanpritom/heart-attack-analysis-prediction-dataset)

## Contenido del dataset {.unlisted .unnumbered}

Las variables que tiene el dataset son: `r toString(heartAttack.var_names)`. Siendo `output` la variable objetivo. A continuación se detallan más en profundidad.

+ **age**: Edad del paciente.
+ **sex**: Género del paciente.
  - *0*: Femenino
  - *1*: Masculino
+ **cp**: Tipo de dolor en el pecho.
  - *0*: Angina típica
  - *1*: Angina atípica
  - *2*: Dolor no anginal
  - *3*: Asintomático
+ **trtbps**: Presión arterial en reposo (en mm Hg).
+ **chol**: Colesterol en mg/dl medido mediante un sensor BMI.
+ **fbs**: Nivel de azúcar en sangre en ayunas (> 120 mg/dl).
  - *1*: Verdadero
  - *0*: Falso
+ **restecg**: Resultados electrocardiográficos en reposo.
  - *0*: Normal
  - *1*: Anormalidad con inversiones de onda ST-T y/o alteraciones del segmento ST > 0.05 mV
  - *2*: Hipertrofia ventricular izquierda
+ **thalach**: Ritmo cardíaco máximo alcanzado.
+ **exng**: Angina inducida por ejercicio.
  - *1*: Sí
  - *0*: No
+ **oldpeak**: Diferencia entre la depresión del segmento ST durante el ejercicio y durante el descanso en un electrocardiograma.
+ **slp**: Pendiente del segmento ST durante el ejercicio en la prueba de esfuerzo.
  - *1*: Ascendente
  - *2*: Plana
  - *3*: Descendente
+ **caa**: Número de vasos principales (0-3).
+ **thall**:  Talasemia, trastorno hereditario de la sangre caracterizado por un menor nivel de hemoglobina.
  - *0*: Ausencia
  - *1*: Talasemia normal
  - *2*: Talasemia fija defectuosa
  - *3*: Talasemia Reversible defectuosa
+ **output**: Variable objetivo.
  - *0*: Menor probabilidad de ataque al corazón
  - *1*: Mayor probabilidad de ataque al corazón

***

# 2. Integración y selección de variables

Observando los dos ficheros csv, **`heart.csv`** tiene **`r ncol(heartAttack)` variables** y **`r nrow(heartAttack)` registros** mientras que **`o2Saturation.csv`** con **1 variable** y **3585 registros**.

Aunque el nivel de saturación de oxigeno pueda ser importante para los ataques cardíacos, no hay manera de juntar los dos conjuntos de datos en uno solo debido a que no hay un identificador de paciente, por lo que solo usaremos `heart.csv`.

Para la selección de los datos, aprovechando de que todas las variables son numéricas se puede comprobar la correlación entre ellas

```{r echo=FALSE, message=FALSE, warning=FALSE}
cor.pearson <- cor(heartAttack, method= "pearson")
corrplot(cor.pearson,method="color",tl.col="black", tl.srt=45, order = "AOE", tl.cex=0.7,
number.cex=0.7,sig.level = 0.01, addCoef.col = "firebrick")

cor.pearson.output <- round(cor.pearson["output",],2)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
cor.pearson.length <- length(names(cor.pearson.output))
cor.pearson.output.row <-
  paste(paste0(names(cor.pearson.output)[-cor.pearson.length], " = ", cor.pearson.output[-cor.pearson.length]), collapse = ", ")
cor.pearson.output.rowFixed <- sub(",\\s(?!.*,\\s)", " y ", cor.pearson.output.row, perl = TRUE)
```

Tanto una correlación positiva como una muy negativa son interesantes para la selección de variables. Centrándonos en la fila de la variable objetivo `output` se tienen los siguientes valores: `r cor.pearson.output.rowFixed`.

Se puede tomar como referencia 0.15 como umbral para comprobar las variables que no son necesarias para el estudio, siempre en valor absoluto. En este caso para el coeficiente de correlación de pearson se tienen `exng`, `oldpeak`, `cp`, `thalachh`, `caa`, `slp`, `thall`, `sex` y `age` como variables aptas y `trtbps`, `restecg`, `chol` y `fbs` como poco importantes. Sin embargo para las variables categóricas numéricas seria más apropiado hacer un test de `Fisher` o un `Chi-squared`.

Se va a proceder a hacer uso del test de `Fisher`

$p = \frac{{\binom{{a+b}}{{a}} \cdot \binom{{c+d}}{{c}}}}{{\binom{{n}}{{a+c}}}}$

```{r echo=FALSE, message=FALSE, warning=FALSE}
heartAttack.fisher.sex <- fisher.test(heartAttack$sex, heartAttack$output)
heartAttack.fisher.cp <- fisher.test(heartAttack$cp, heartAttack$output)
heartAttack.fisher.fbs <- fisher.test(heartAttack$fbs, heartAttack$output)
heartAttack.fisher.restecg <- fisher.test(heartAttack$restecg, heartAttack$output)
heartAttack.fisher.exng <- fisher.test(heartAttack$exng, heartAttack$output)
heartAttack.fisher.slp <- fisher.test(heartAttack$slp, heartAttack$output)
heartAttack.fisher.caa <- fisher.test(heartAttack$caa, heartAttack$output)
heartAttack.fisher.thall <- fisher.test(heartAttack$thall, heartAttack$output)
```

Se obtiene que:

+ **sex** tiene un p-value de `r heartAttack.fisher.sex$p.value` que es menor a 0.05, con lo que es estadisticamente significativa
+ **cp** tiene un p-value de `r heartAttack.fisher.cp$p.value` que es menor a 0.05, con lo que es estadisticamente significativa
+ **fbs** tiene un p-value de `r heartAttack.fisher.fbs$p.value` que es mayor a 0.05, con lo que no es estadisticamente significativa
+ **restecg** tiene un p-value de `r heartAttack.fisher.restecg$p.value` que es menor a 0.05, con lo que es estadisticamente significativa
+ **exng** tiene un p-value de `r heartAttack.fisher.exng$p.value` que es menor a 0.05, con lo que es estadisticamente significativa
+ **slp** tiene un p-value de `r heartAttack.fisher.slp$p.value` que es menor a 0.05, con lo que es estadisticamente significativa
+ **caa** tiene un p-value de `r heartAttack.fisher.caa$p.value` que es menor a 0.05, con lo que es estadisticamente significativa
+ **thall** tiene un p-value de `r heartAttack.fisher.thall$p.value` que es menor a 0.05, con lo que es estadisticamente significativa

***

# 3. Limpieza de los datos

FIXME

```{r echo=TRUE, message=FALSE, warning=FALSE}
str(heartAttack)
```

FIXME

```{r echo=TRUE, message=FALSE, warning=FALSE}
summary(heartAttack)
```

FIXME

```{r echo=TRUE, message=FALSE, warning=FALSE}
# FIXME
```

FIXME

## 3.1. ¿Los datos contienen ceros o elementos vacíos?

Tenemos algunas variables categóricas en formato numérico en nuestro conjunto de datos. Estas variables no se pueden considerar en la búsqueda de ceros, ya que el valor 0 es una de las posibles categorías para cada una de ellas. Las variables categóricas en formato numérico son `sex`, `cp`, `fbs`, `restecg`, `exng`, `slp`,`caa`, `thall` y `output`. De las cuales son dicotomicas `sex`, `fbs`, `exng` y `output`.

FIXME

+ **age**: `r length(which(heartAttack$age==0))`
+ **trtbps**: `r length(which(heartAttack$trtbps==0))`
+ **chol**: `r length(which(heartAttack$chol==0))`
+ **thalach**: `r length(which(heartAttack$thalach==0))`
+ **oldpeak**: `r length(which(heartAttack$oldpeak==0))`


FIXME

## 3.2. Identifica y gestiona los valores extremos

FIXME

***

# 4. Análisis de los datos

FIXME

## 4.1. Selección de los grupos de datos que se quieren analizar/comparar

FIXME

## 4.2. Comprobación de la normalidad y homogeneidad de la varianza

FIXME

## 4.3. Aplicación de pruebas estadísticas para comparar los grupos de datos

FIXME

***

# 5. Representación de los resultados

FIXME

***

# 6. Resolución del problema

FIXME

***

# 7. Código

FIXME

***

# 8. Vídeo

FIXME